// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: skus.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const adjustSKUStock = `-- name: AdjustSKUStock :one
UPDATE skus
SET stock_count = stock_count + $2,
    updated_at  = now()
WHERE uuid = $1
RETURNING id, uuid, book_id, store_id, price_in_kopeks, stock_count, created_at, updated_at, deleted_at
`

type AdjustSKUStockParams struct {
	Uuid     pgtype.UUID `json:"uuid"`
	ChangeBy int32       `json:"change_by"`
}

func (q *Queries) AdjustSKUStock(ctx context.Context, arg AdjustSKUStockParams) (Sku, error) {
	row := q.db.QueryRow(ctx, adjustSKUStock, arg.Uuid, arg.ChangeBy)
	var i Sku
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.BookID,
		&i.StoreID,
		&i.PriceInKopeks,
		&i.StockCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createSKU = `-- name: CreateSKU :one
INSERT INTO skus (book_id, store_id, price_in_kopeks, stock_count)
VALUES ($1, $2, $3, $4)
RETURNING id, uuid, book_id, store_id, price_in_kopeks, stock_count, created_at, updated_at, deleted_at
`

type CreateSKUParams struct {
	BookID        int64 `json:"book_id"`
	StoreID       int64 `json:"store_id"`
	PriceInKopeks int32 `json:"price_in_kopeks"`
	StockCount    int32 `json:"stock_count"`
}

func (q *Queries) CreateSKU(ctx context.Context, arg CreateSKUParams) (Sku, error) {
	row := q.db.QueryRow(ctx, createSKU,
		arg.BookID,
		arg.StoreID,
		arg.PriceInKopeks,
		arg.StockCount,
	)
	var i Sku
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.BookID,
		&i.StoreID,
		&i.PriceInKopeks,
		&i.StockCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSKUByUUID = `-- name: GetSKUByUUID :one
SELECT s.id, s.uuid, s.book_id, s.store_id, s.price_in_kopeks, s.stock_count, s.created_at, s.updated_at, s.deleted_at, b.id, b.isbn, b.title, b.author, b.description, b.page_count, b.publication_year, b.created_at, b.updated_at, b.deleted_at
FROM skus s
         JOIN books b ON s.book_id = b.id
WHERE s.uuid = $1
  AND s.deleted_at IS NULL
`

type GetSKUByUUIDRow struct {
	Sku  Sku  `json:"sku"`
	Book Book `json:"book"`
}

func (q *Queries) GetSKUByUUID(ctx context.Context, uuid pgtype.UUID) (GetSKUByUUIDRow, error) {
	row := q.db.QueryRow(ctx, getSKUByUUID, uuid)
	var i GetSKUByUUIDRow
	err := row.Scan(
		&i.Sku.ID,
		&i.Sku.Uuid,
		&i.Sku.BookID,
		&i.Sku.StoreID,
		&i.Sku.PriceInKopeks,
		&i.Sku.StockCount,
		&i.Sku.CreatedAt,
		&i.Sku.UpdatedAt,
		&i.Sku.DeletedAt,
		&i.Book.ID,
		&i.Book.Isbn,
		&i.Book.Title,
		&i.Book.Author,
		&i.Book.Description,
		&i.Book.PageCount,
		&i.Book.PublicationYear,
		&i.Book.CreatedAt,
		&i.Book.UpdatedAt,
		&i.Book.DeletedAt,
	)
	return i, err
}

const listBookAvailability = `-- name: ListBookAvailability :many
SELECT s.id, s.uuid, s.book_id, s.store_id, s.price_in_kopeks, s.stock_count, s.created_at, s.updated_at, s.deleted_at, st.id, st.uuid, st.name, st.address, st.created_at, st.updated_at, st.deleted_at
FROM skus s
         JOIN stores st ON s.store_id = st.id
WHERE s.book_id = $1
  AND s.deleted_at IS NULL
  AND st.deleted_at IS NULL
`

type ListBookAvailabilityRow struct {
	Sku   Sku   `json:"sku"`
	Store Store `json:"store"`
}

func (q *Queries) ListBookAvailability(ctx context.Context, bookID int64) ([]ListBookAvailabilityRow, error) {
	rows, err := q.db.Query(ctx, listBookAvailability, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBookAvailabilityRow
	for rows.Next() {
		var i ListBookAvailabilityRow
		if err := rows.Scan(
			&i.Sku.ID,
			&i.Sku.Uuid,
			&i.Sku.BookID,
			&i.Sku.StoreID,
			&i.Sku.PriceInKopeks,
			&i.Sku.StockCount,
			&i.Sku.CreatedAt,
			&i.Sku.UpdatedAt,
			&i.Sku.DeletedAt,
			&i.Store.ID,
			&i.Store.Uuid,
			&i.Store.Name,
			&i.Store.Address,
			&i.Store.CreatedAt,
			&i.Store.UpdatedAt,
			&i.Store.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSKUsByStore = `-- name: ListSKUsByStore :many
SELECT s.id, s.uuid, s.book_id, s.store_id, s.price_in_kopeks, s.stock_count, s.created_at, s.updated_at, s.deleted_at, b.id, b.isbn, b.title, b.author, b.description, b.page_count, b.publication_year, b.created_at, b.updated_at, b.deleted_at
FROM skus s
         JOIN books b ON s.book_id = b.id
WHERE s.store_id = $1
  AND s.deleted_at IS NULL
`

type ListSKUsByStoreRow struct {
	Sku  Sku  `json:"sku"`
	Book Book `json:"book"`
}

func (q *Queries) ListSKUsByStore(ctx context.Context, storeID int64) ([]ListSKUsByStoreRow, error) {
	rows, err := q.db.Query(ctx, listSKUsByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSKUsByStoreRow
	for rows.Next() {
		var i ListSKUsByStoreRow
		if err := rows.Scan(
			&i.Sku.ID,
			&i.Sku.Uuid,
			&i.Sku.BookID,
			&i.Sku.StoreID,
			&i.Sku.PriceInKopeks,
			&i.Sku.StockCount,
			&i.Sku.CreatedAt,
			&i.Sku.UpdatedAt,
			&i.Sku.DeletedAt,
			&i.Book.ID,
			&i.Book.Isbn,
			&i.Book.Title,
			&i.Book.Author,
			&i.Book.Description,
			&i.Book.PageCount,
			&i.Book.PublicationYear,
			&i.Book.CreatedAt,
			&i.Book.UpdatedAt,
			&i.Book.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSKUPrice = `-- name: UpdateSKUPrice :one
UPDATE skus
SET price_in_kopeks = $2,
    updated_at      = now()
WHERE uuid = $1
RETURNING id, uuid, book_id, store_id, price_in_kopeks, stock_count, created_at, updated_at, deleted_at
`

type UpdateSKUPriceParams struct {
	Uuid          pgtype.UUID `json:"uuid"`
	PriceInKopeks int32       `json:"price_in_kopeks"`
}

func (q *Queries) UpdateSKUPrice(ctx context.Context, arg UpdateSKUPriceParams) (Sku, error) {
	row := q.db.QueryRow(ctx, updateSKUPrice, arg.Uuid, arg.PriceInKopeks)
	var i Sku
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.BookID,
		&i.StoreID,
		&i.PriceInKopeks,
		&i.StockCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
